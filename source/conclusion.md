# Conclusion

## Evolution du projet
Le projet est passé par une multitude de stades et de prototypes avant d'être clair dans ses objectifs et dans sa direction au niveau du développement.

Au commencement, l'outil se voulait être basé sur l'interaction directe de l'utilisateur avec les cartes qui composent la liste. En effet, l'un des premiers prototypes avait comme fonctionnalité primaire le déplacement de cartes à l'aide de la souris. Les interactions directes avec le jeu de carte (qui représente une liste d'éléments) étaient censées générer une sorte de pseudo-code qui décrit l'équivalent de l'action qui a été effectuée. Par exemple si l'utilisateur avait retourner la troisième carte de la liste, une instruction du type ```RetourneCarte(3)``` aurait été généré. Cette instruction, stockée dans un historique aurait pu permettre de rejouer les action effectuées par l'utilisateur. Ainsi, ce dernier aurait pu simuler le comportement d'un algorithme afin de réellement comprendre comment il opère. Réciproquement, l'historique aurait pu contenir à l'avance toutes les actions que performe un algorithme afin de pouvoir rejouer cet algorithme devant l'utilisateur. Le but était de se détacher d'un langage de programmation afin de ne pas être limité par lui dans la compréhension des instructions générées par l'outil.

Finalement, le projet a évolué sur une approche plus personnalisable et plus ouverte au niveau de l'implémentation de l'outil afin de s'adapter aux besoins spécifiques de chaques enseignants. De plus, par son API, dont les fonctions peuvent être appelé directement à parti de code concret (Python, JavaScript ou autres langages), l'outil apporte une vision plus réaliste de la façon dont un algorithme est écrit avec du code réel. Cependant, l'aspect d'interaction entre l'outil et l'utilisateur reste présent, du moment que l'élève a la possibilité d'appelé des fonctions de l'API directement ou indirectement. Ainsi, l'implémentation de l'API dans un programme tier devrait conserver l'interaction afin de poursuivre la philosophie sur laquelle l'outil a été développé ; il s'agit du constructivisme, une méthode d'apprentissage basé sur la représentation qu'élève construit avec les interactions qu'il a eu avec un objet.

## Difficultés rencontrées lors du développement
A défaut d'avoir rencontré de nombreuses difficultés techniques, l'accroc principal a été la gestion du temps. En effet, l'estimation du temps pour l'ajout d'une fonctionnalité est très souvent largement inférieure à la réalité car de nombreux petits détails techniques n'apparaissent pas dans l'image globale qu'on s'imagine pour implémenter la fonctionnalité. De plus, programmer exige une grande concentration et d'être totalement impliqué afin d'être productif. Une certaine fatigue mentale survient donc rapidement et des pauses plus ou moins fréquentes sont nécessaires.

Une autre difficulté majeure rencontrée a été la gestion des animations. En effet, il s'agissait de mettre de l'ordre dans la manière dont les animations sont jouées. Par exemple, si une animation est en train d'être jouée et que, par la continuité du code, une autre animation doit être jouée, il faut attendre que la première animation soit finie avant de jouer la deuxième. Mais peut-être que l'on souhaite que les deux animations se jouent simultanément ? Il fallait permettre au développeur d'expliciter parfaitement comment les animations doivent s'enchaîner afin de prévenir tout comportement indéterminé (le code qui joue les animations est asynchrone, une animation qui dépend d'une autre n'a donc aucune connaissance de l'état de cette dernière). Cette difficulté a été surmonté grâce au système d'animation, comme expliqué dans la partie "Fonctionnement de l’outil", notamment grâce au stockage de différents types d'animations dans une liste.